/*
     ä»€ä¹ˆæ˜¯å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Ÿ
     åœ¨Rustä¸­å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ‰€æœ‰æƒæ˜¯æ˜ç¡®çš„ï¼Œå³æ‰€æœ‰æƒåªå±äºä¸€ä¸ªå®ä¾‹ï¼Œå¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Œå³ï¼šRc<T>ã€‚å¯ä»¥å¯ç”¨å¤šæ‰€æœ‰æƒè¿›è¡Œçš„æ‰€æœ‰æƒçš„å…±äº«ã€‚
     ä¸¾ä¸€ä¸ªå¸¸è§çš„éœ€æ±‚ï¼šåœ¨å›¾æ•°æ®ç»“æ„ä¸­ï¼Œå¤šä¸ªè¾¹å¯èƒ½æŒ‡å‘ç›¸åŒçš„èŠ‚ç‚¹ï¼Œè€Œè¿™ä¸ªèŠ‚ç‚¹ä»æ¦‚å¿µä¸Šè®²ä¸ºæ‰€æœ‰æŒ‡å‘å®ƒçš„è¾¹æ‰€æ‹¥æœ‰ã€‚
                    èŠ‚ç‚¹ç›´åˆ°æ²¡æœ‰ä»»ä½•è¾¹æŒ‡å‘å®ƒä¹‹å‰éƒ½ä¸åº”è¯¥è¢«æ¸…ç†å› æ­¤ä¹Ÿæ²¡æœ‰æ‰€æœ‰è€…ã€‚

    å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆçš„åŸç†ï¼Ÿ
    è¯¥æŒ‡é’ˆè®°å½•ä¸€ä¸ªå€¼å¼•ç”¨çš„æ•°é‡æ¥çŸ¥æ™“è¿™ä¸ªå€¼æ˜¯å¦ä»åœ¨è¢«ä½¿ç”¨ã€‚å¦‚æœæŸä¸ªå€¼æœ‰é›¶ä¸ªå¼•ç”¨ï¼Œå°±ä»£è¡¨æ²¡æœ‰ä»»ä½•æœ‰æ•ˆå¼•ç”¨å¹¶å¯ä»¥è¢«æ¸…ç†ã€‚

    å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆçš„ç¼ºç‚¹ï¼Ÿ
    <1>å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆåªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯ï¼Œå¦‚æœæ˜¯å¤šçº¿åœºæ™¯ä¸‹æ¨èä½¿ç”¨ï¼šåŸå­å¼•ç”¨è®¡æ•°Arc<T>ã€‚
    <2>å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆæ™ºèƒ½ç”¨äºè¯»å–æ•°æ®ï¼Œå¹¶ä¸èƒ½ä¿®æ”¹æ•°æ®ï¼Œå¦åˆ™å°±ä¼šæœ‰å¤šä¸ªå¯å˜å¼•ç”¨çš„é—®é¢˜ä»è€ŒèŒƒå›´äº†Rustçš„å€Ÿç”¨è§„åˆ™ï¼Œä¸€èˆ¬æ¨èä½¿ç”¨RefCell<T>
 */
fn main() {
    // graph_list_for_rc();
    trace_rc();
}

// [case-0] æ™ºèƒ½æŒ‡é’ˆBoxæ¡ˆä¾‹å›é¡¾

// Consæ•°æ®ç»“æ„æšä¸¾å®šä¹‰
/*
enum List {
    Cons(i32, Box<List>),
    Nil,
}
*/

// â“ æˆ‘ä»¬èƒ½å¤Ÿé€šè¿‡Listè¿™ç§æšä¸¾æ•°æ®ç»“æ„è§£å†³ä¸‹é¢çš„é—®é¢˜ï¼š
/*
    <<b>>
    +-------+
    | 3 |   |===+
    +-------+   |
                |
                |    <<a>>
                |    +-------+         +--------+  
                |==> | 5 |   |  =====> | 10 |   |  =====>  <Nil>
                |    +-------+         +--------+
                |
    <<c>>       |
    +-------+   |
    | 4 |   |===+
    +-------+
     
 */

// âŒ
// value used here after move
// å‡ºé”™çš„åŸå› ä¸»è¦æ˜¯ç”±äºï¼šCons æˆå‘˜æ‹¥æœ‰å…¶å‚¨å­˜çš„æ•°æ®ï¼Œæ‰€ä»¥å½“åˆ›å»º b åˆ—è¡¨æ—¶ï¼Œa è¢«ç§»åŠ¨è¿›äº† b è¿™æ · b å°±æ‹¥æœ‰äº† aã€‚
//                   æ¥ç€å½“å†æ¬¡å°è¯•ä½¿ç”¨ a åˆ›å»º c æ—¶ï¼Œè¿™ä¸è¢«å…è®¸ï¼Œå› ä¸º a çš„æ‰€æœ‰æƒå·²ç»è¢«ç§»åŠ¨ã€‚
// æ€»ç»“ï¼šConsç±»å‹çš„æ•°æ®ç»“æ„bå’Œå‘åŒæ—¶æ‹¥æœ‰Consç±»å‹çš„a
/*
use crate::List::{Cons, Nil};
fn graph_list_for_box() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a)); // âŒ
}
*/

// [case-1] å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ
// æ³¨æ„ï¼š
//      <1> éœ€è¦ä½¿ç”¨ use è¯­å¥å°† Rc<T> å¼•å…¥ä½œç”¨åŸŸï¼Œå› ä¸ºå®ƒä¸åœ¨ prelude ä¸­ã€‚
//      <2> å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆéœ€è¦ä½¿ç”¨Rc::cloneçš„å…³è”å‡½æ•°è¿›è¡Œå¼•ç”¨è®¡æ•°ã€‚
//      <3> å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆçš„cloneå‡½æ•°å®ç°å¹¶ä¸åƒå¤§éƒ¨åˆ†ç±»å‹çš„ clone å®ç°é‚£æ ·å¯¹æ‰€æœ‰æ•°æ®è¿›è¡Œæ·±æ‹·è´ã€‚

// å¼•ç”¨å¼•ç”¨æ™ºèƒ½æŒ‡é’ˆ
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn graph_list_for_rc() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); // a: Rc<List>
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}

// [case-2] å¦‚ä½•æ˜¾å¼çš„æŸ¥çœ‹å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆçš„å¼•ç”¨è®¡æ•°
// æ³¨æ„ï¼š
//       <1> è¿™é‡Œé€šè¿‡Rcçš„strong_countå…³è”å‡½æ•°æŸ¥çœ‹ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆçš„å¼•ç”¨è®¡æ•°
/*
    ğŸª¢
    [count after creating <<a>>]: 1
    [count after creating <<b>>]: 2
    [count after <<c>> goes in scope]: 3
    [count after <<c>> goes out of scope]: 2
    [count after <<b>> has been dropped]: 1
 */
fn trace_rc() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("[count after creating <<a>>]: {}", Rc::strong_count(&a));          // 1

    let b = Cons(3, Rc::clone(&a));
    println!("[count after creating <<b>>]: {}", Rc::strong_count(&a));          // 2

    {
        let c = Cons(4, Rc::clone(&a));
        println!("[count after <<c>> goes in scope]: {}", Rc::strong_count(&a)); // 3
    }

    println!("[count after <<c>> goes out of scope]: {}", Rc::strong_count(&a)); // 2

    drop(b);
    println!("[count after <<b>> has been dropped]: {}", Rc::strong_count(&a));  // 1
}
